# 7.7周报

## 今日计划
1. 尝试pr
2. 语言（Go）的学习
3. 涉及知识的学习

## 完成情况
### 关于pull request
   （晚上尝试&了解）


### 关于Go
1. **range**（range 关键字用于 for 循环中迭代数组(array)、切片(slice)、通道(channel)或集合(map)的元素）
- 在map中返回其中的key值
-使用for...range循环
  其中的value，是一个值拷贝，而不是元素本身
2. **map**（无序的）
- 定义除用关键字外还可以用make函数
> 一种元素对（pair）的无序集合，pair 的一个元素是key，对应的另一个元素是value，所以这个结构也称为关联数组或字典。这是一种快速寻找值的理想结构：给定key，对应的value可以迅速定位。
- comma-ok断言（类型断言）
  > value, ok := element.(T)
  > element：要判断的变量，element必须是interface类型
  > T：被判断的类型，普通类型
  > value：返回的值
  > ok：是否为该类型
  > 如果断言失败，ok为false，否则ok为true并且value为变量的值
- delete( )函数删除集合中的元素
  delete(map,key)则删除map中对应key元素
    ```Go
            m := make(map[string]int)
  
            m["Answer"] = 42 //在map m中插入或修改元素
           
            m["Answer"] = 48
  
            delete(m, "Answer")  //删除元素
  
            v, ok := m["Answer"]      检测某个值是否存在
       ```
3. **语言类型转换**
4. **接口**(任何其他类型只要实现了这些方法就是实现了这个接口???)
5.  **goroutine与channel**
    1. c.f.并发&并行
> 并发是两个任务可以在重叠的时间段内启动，运行和完成；是独立执行过程的组合；是一次处理很多事情
> 并行是任务在同一时间运行，例如，在多核处理器上；是同时执行（可能相关的）计算；是同时做很多事情
> 应用程序可以是并发的，但不是并行的，这意味着它可以同时处理多个任务，但是没有两个任务在同一时刻执行
> 应用程序可以是并行的，但不是并发的，这意味着它同时处理多核CPU中的任务的多个子任务
> 一个应用程序可以既不是并行的，也不是并发的，这意味着它一次一个地处理所有任务
> 应用程序可以即是并行的也是并发的，这意味着它同时在多核CPU中同时处理多个任务
   2. goroutine
        对进行的操作前加go，然后main中执行的操作就无需等待这步进行并一步一步进行操作
   3. channel（主要做goroutine间变量共享和控制的）
    * <-  信道操作符
    ``` Go
      ch <- v    // 将 v 发送至信道 ch，此时 <-是发送操作符
      v := <-ch  // 从 ch 接收值并赋予 v，此时<-是接收操作符
    ```
    * 信道在使用前必须创建：
    ```Go
       ch := make(chan int)
    ```
   * 先进先出
     在发送过程中进行的元素值属于完全复制(通道起一个传递作用，接受处即是在发送处的值，如果在发送后接收前对改值进行了操作，也不改变接受处的情况，且变量本身会有变化)
   * 用make函数（内建函数 make 用来为 slice，map 或 chan 类型分配内存和初始化一个对象）
   4. 死锁（？？？）
   * 所有的线程或进程都在等待资源的释放
   * 非缓冲信道上如果发生了流入无流出，或者流出无流入，会导致了死锁，Go启动的所有goroutine里的非缓冲信道一定要一个线里存数据，一个线里取数据，要成对


7. **if err ！=nil{}**
   用于判断是否有error且可以继续进行，并返回error

### 关于认证
- 当前后端分离时我们会因为同源策略而无法设置cookie和session

to be continued
明日继续
